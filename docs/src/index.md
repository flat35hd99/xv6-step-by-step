---
title: xv6をゼロから作る
---

[xv6のRISC-V版](mit-pdos/xv6-riscv)をインクリメンタルに作成するにはどうやればいいのか調べます。少しずつ作成するにあたり、常になにかしらのOSが動き、かつそれが正常であることを検証できる自動テストをメンテしながら開発する方法を模索します。

## Hello, world

QEMU上で動く、"Hello, world!" OSを作成します。

QEMU上で動かすのはブートローダを自分で書いたり、仕様を調べたりしなくてよいため、比較的簡単です。`-kernel`オプションで渡したelfファイルをメモリ上に展開してくれるため、適切なメモリ配置になるようにすればよいです。そのため、メモリ配置を指示するためのリンクファイルと、プログラムファイル本体を用意することになります。

本家では、それぞれ`kernel.ld`と`entry.S`, `main.c`が対応しています。このプロジェクトでも同じファイル名で作成します。

初期化は以下の流れで行われています。

- `main.c/main()`
  - `console.c/consoleinit()`
    - `console.c/uartinit()`
  - `printf.c/printfinit()`

`printf()`の中身から、`uart.c`のいろいろが使われてるのがわかるので、それらを呼び出せるようにします。

コンパイルと実行は、それぞれ `compile.sh`と`run.sh`を実行することで行えます。どちらも本家のMakefileから持ってきています。

```console
$ cd /path/to/xv6-step-by-step
$ ./compile.sh
$ ./run.sh
hello, world
```

実行すると、"hello, world"の文字列が表示されました🎉🎉🎉

### おさらい

- QEMUでHello, Worldに成功した。
- とりあえず動かすため、細かいお話、たとえばUARTの仕様やロック周りについては触れなかった。
- CPU数は1つで実行した。

## マルチコアでHello, World!

`run.sh`と`start.c`のCPUSの宣言を`1`から`2`へ変更して実行すると以下のように`hello, world`が連続して表示されます。

```
$ ./compile.sh && ./run.sh
hello, world
hello, world
```

問題なさそうです。ここから、cpu数に応じて、表示される`hello, world`の数が比例して増加すると予想できます。CPUS=3のときを試すと

```
$ ./compile.sh && ./run.sh
hhello, world
ello, world
hello, world
```

残念ながら崩れてしまいました。これはきっと、複数のコアが同時に一つのUARTのバッファかレジスタ、またはその両方へ書き込みを行っているために生じる現象だと推察されます。いわゆる、競合状態(race condition)です。競合状態を回避するためには、ロック・アンロックやセマフォといった、同期を取る仕組みが必要です。このような仕組みは、OSとハードウェアが協力することで提供されるので、このプロジェクトでも作成が自分で作る必要があります。

ただし、ここで同期機能を提供するのは時期尚早に思えます。そのため今回は"hello, world"は一回だけ表示させるために、`hartid`が1のときだけ`hello_world()`を呼び出すように変更します。

```c
if (r_mhartid() == 1)
  hello_world();
```

"hello, world"が一回だけ表示され、また、文字列の順序が崩れてしまうこともなくなります。

```
$ ./compile.sh && ./run.sh
hello, world
```

とりあえず競合状態を回避することができました。

### おさらい

- CPU数を増やすと競合状態に陥り、"hello, world"の文字列が期待通りには表示されなくなってしまった。
- `hartid`が1のときだけ"hello, world"を表示することで、この問題を回避した。

## debug

loadx前。

- 0xA0000000: なんか配置されてる
- 0x40000000: アクセスできなかった。

```
StarFive # md 0xA0000000
a0000000: 5f746466 68676968 6678303d 66666666  fdt_high=0xfffff
a0000010: 66666666 66666666 0a666666 74696e69  fffffffffff.init
a0000020: 685f6472 3d686769 66667830 66666666  rd_high=0xffffff
a0000030: 66666666 66666666 6b0a6666 656e7265  ffffffffff.kerne
a0000040: 64615f6c 725f7264 3478303d 30303034  l_addr_r=0x44000
a0000050: 0a303030 6e72656b 635f6c65 5f706d6f  000.kernel_comp_
a0000060: 72646461 303d725f 30303978 30303030  addr_r=0x9000000
a0000070: 656b0a30 6c656e72 6d6f635f 69735f70  0.kernel_comp_si
a0000080: 303d657a 30303178 30303030 64660a30  ze=0x10000000.fd
a0000090: 64615f74 725f7264 3478303d 30303038  t_addr_r=0x48000
a00000a0: 0a303030 646d6172 5f6b7369 72646461  000.ramdisk_addr
a00000b0: 303d725f 31383478 30303030 20230a30  _r=0x48100000.#
a00000c0: 65766f4d 73696420 206f7274 66206f74  Move distro to f
a00000d0: 74737269 6f6f6220 6f742074 65707320  irst boot to spe
a00000e0: 75206465 6f622070 6e69746f 6f620a67  ed up booting.bo
a00000f0: 745f746f 65677261 643d7374 72747369  ot_targets=distr
StarFive # 0X40000000
Unknown command '0X40000000' - try 'help'
StarFive # md 0x40000000
Unhandled exception: Load access fault
EPC: 00000000fffa010e RA: 00000000fffa005c TVAL: 0000000040000000
EPC: 000000004025a10e RA: 000000004025a05c reloc adjusted

SP:  00000000ff7358c0 GP:  00000000ff735e00 TP:  0000000000000001
T0:  00000000ff735b40 T1:  0000000000000039 T2:  0000000000000000
S0:  0000000000000004 S1:  0000000000000004 A0:  0000000000000004
A1:  00000000fffb6c98 A2:  00000000fffb9806 A3:  fffffffffffffffe
A4:  0000000000000008 A5:  0000000000000000 A6:  0000000000000002
A7:  0000000000000004 S2:  00000000ff735a99 S3:  0000000000000004
S4:  00000000ff7359d8 S5:  0000000040000000 S6:  0000000000000000
S7:  00000000ff7359d8 S8:  0000000000000008 S9:  00000000ff7359d8
S10: 0000000000000008 S11: 0000000000000004 T3:  0000000000000010
T4:  0000000000000000 T5:  000000000001869f T6:  00000000ff735b20

Code: 6c0a 7ce6 7d46 7da6 6169 8082 9c63 03b4 (a683 000a)


resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
```

loadxしてからmdしてみる。

loadxしたら`0xA0000000`に配置されたので、

```
StarFive # md 0xA0000000
a0000000: 464c457f 00010102 00000000 00000000  .ELF............
a0000010: 00f30002 00000001 40000000 00000000  ...........@....
a0000020: 00000040 00000000 00002f50 00000000  @.......P/......
a0000030: 00000005 00380040 00400002 00120013  ....@.8...@.....
a0000040: 00000001 00000007 00001000 00000000  ................
a0000050: 40000000 00000000 40000000 00000000  ...@.......@....
a0000060: 00001030 00000000 00003060 00000000  0.......`0......
a0000070: 00001000 00000000 6474e551 00000006  ........Q.td....
a0000080: 00000000 00000000 00000000 00000000  ................
a0000090: 00000000 00000000 00000000 00000000  ................
a00000a0: 00000000 00000000 00000010 00000000  ................
a00000b0: 00000000 00000000 00000000 00000000  ................
a00000c0: 00000000 00000000 00000000 00000000  ................
a00000d0: 00000000 00000000 00000000 00000000  ................
a00000e0: 00000000 00000000 00000000 00000000  ................
a00000f0: 00000000 00000000 00000000 00000000  ................
```

`bootelf`は死ぬ。`iminfo`は認識できないという。

### elfの認識自体がダメ？

どうやらreturn codeをu-boot側で拾えるらしいので、

```c
void main() {
  return 42;
}
```

という簡単なコードを `riscv64-linux-gnu-gcc main.c` でコンパイルした。`a.out`という名前だが、elf形式らしい。

```console
StarFive # loadx
## Ready for binary (xmodem) download to 0xA0000000 at 115200 bps...
C## Total Size      = 0x000020c8 = 8392 Bytes
StarFive # iminfo

## Checking Image at a0000000 ...
Unknown image format!
```

😫

```console
StarFive # md a0000000
a0000000: 464c457f 00010102 00000000 00000000  .ELF............
a0000010: 00f30003 00000001 00000520 00000000  ........ .......
a0000020: 00000040 00000000 00001a08 00000000  @...............
a0000030: 00000005 00380040 00400009 001a001b  ....@.8...@.....
a0000040: 00000006 00000004 00000040 00000000  ........@.......
a0000050: 00000040 00000000 00000040 00000000  @.......@.......
a0000060: 000001f8 00000000 000001f8 00000000  ................
a0000070: 00000008 00000000 00000003 00000004  ................
a0000080: 00000238 00000000 00000238 00000000  8.......8.......
a0000090: 00000238 00000000 00000021 00000000  8.......!.......
a00000a0: 00000021 00000000 00000001 00000000  !...............
a00000b0: 00000001 00000005 00000000 00000000  ................
a00000c0: 00000000 00000000 00000000 00000000  ................
a00000d0: 00000694 00000000 00000694 00000000  ................
a00000e0: 00001000 00000000 00000001 00000006  ................
a00000f0: 00000df8 00000000 00001df8 00000000  ................
```

ちゃんとELFに見える。

```console
StarFive # bootelf -p a0000000
## Not a 32-bit elf image at address 0xa0000000
```

32bitじゃないと怒られてる。`-s`でも同じだった。

## objcopyを使ってraw binaryにしてgoで起動

生成

```console
riscv64-linux-gnu-as -mabi=lp64 -o hello hello.S
riscv64-linux-gnu-objcopy -O binary hello hello.bin
riscv64-linux-gnu-objcopy -O binary kernel/kernel kernel.bin
```

```console
StarFive # loadx
## Ready for binary (xmodem) download to 0xA0000000 at 115200 bps...
C## Total Size      = 0x00001030 = 4144 Bytes

```

recoveryは動くのか見る

```
Welcome to minicom 2.8

OPTIONS: I18n
Port /dev/serial0, 00:34:43

Press CTRL-A Z for help on special keys

CCCCCCCCCCCC
JH7110 secondboot version: 221205-74596a9
CPU freq: 1250MHz
idcode: 0x1860C8
ddr 0x00000000, 4M test
ddr 0x00400000, 8M test
DDR clk 2133M, size 4GB

*********************************************************
****************** JH7110 program tool ******************
*********************************************************
0: update 2ndboot/SPL in flash
1: update 2ndboot/SPL in emmc
2: update fw_verif/uboot in flash
3: update fw_verif/uboot in emmc
4: update otp, caution!!!!
5: exit
NOTE: current xmodem receive buff = 0x40000000, 'load 0x********' to change.
```

### すごい単純な場合

```assembly
.section .text
.global _entry
_entry:
        li ra, 42
spin:
        j spin

```

```console
StarFive # md a0000000
a0000000: 464c457f 00010102 00000000 00000000  .ELF............
a0000010: 00f30002 00000001 a0000000 00000000  ................
a0000020: 00000040 00000000 00002130 00000000  @.......0!......
a0000030: 00000005 00380040 00400002 00070008  ....@.8...@.....
a0000040: 00000001 00000005 00001000 00000000  ................
a0000050: a0000000 00000000 a0000000 00000000  ................
a0000060: 00001000 00000000 00001000 00000000  ................
a0000070: 00001000 00000000 00000001 00000006  ................
a0000080: 00002000 00000000 a0001000 00000000  . ..............
a0000090: a0001000 00000000 00000000 00000000  ................
a00000a0: 00000000 00000000 00001000 00000000  ................
a00000b0: 00000000 00000000 00000000 00000000  ................
a00000c0: 00000000 00000000 00000000 00000000  ................
a00000d0: 00000000 00000000 00000000 00000000  ................
a00000e0: 00000000 00000000 00000000 00000000  ................
a00000f0: 00000000 00000000 00000000 00000000  ................
StarFive # bootelf
## Starting application at 0x00000000 ...
Unhandled exception: Instruction access fault
EPC: 0000000000000000 RA: 00000000fff4b0d0 TVAL: 0000000000000000
EPC: ffffffff402ba000 RA: 00000000402050d0 reloc adjusted

SP:  00000000ff735a30 GP:  00000000ff735e00 TP:  0000000000000001
T0:  00000000a0001000 T1:  00000000fff47262 T2:  0000000000000000
S0:  0000000000000000 S1:  0000000000000001 A0:  0000000000000000
A1:  00000000ff758a98 A2:  000000000000000a A3:  fffffffffffffffe
A4:  0000000000000002 A5:  0000000000000000 A6:  0000000000000021
A7:  0000000000000000 S2:  0000000000000000 S3:  00000000ff758a98
S4:  0000000000000000 S5:  0000000000000001 S6:  0000000000000000
S7:  00000000ff758ad0 S8:  0000000000000000 S9:  0000000000000000
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000010
T4:  0000000000000000 T5:  0000000000000000 T6:  00000000a0000000
Unhandled exception: Load access fault
EPC: 00000000fff473f2 RA: 00000000fff473f2 TVAL: 0000000000000000
EPC: 00000000402013f2 RA: 00000000402013f2 reloc adjusted

SP:  00000000ff7358d0 GP:  00000000ff735e00 TP:  0000000000000001
T0:  00000000a0001000 T1:  00000000fff47262 T2:  0000000000000000
S0:  0000000000000000 S1:  0000000000000000 A0:  0000000000000042
A1:  0000000000000000 A2:  000000000000000a A3:  fffffffffffffffe
A4:  0000000000000002 A5:  0000000010000000 A6:  000000000000000f
A7:  0000000000000000 S2:  0000000000000000 S3:  0000000000000002
S4:  0000000000000000 S5:  0000000000000001 S6:  0000000000000000
S7:  00000000ff758ad0 S8:  0000000000000000 S9:  0000000000000000
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000010
T4:  0000000000000000 T5:  0000000000000000 T6:  00000000a0000000

Code: 2517 0006 0513 0b65 f413 ffe4 b0ef 27d5 (5783 0004)
```

### 成功までの流れ

1. バイナリの配置場所と、ELFに指定された配置場所が同じところになっていたので、おかしなことになっていたと気づいた。
2. バイナリの配置場所と、ELFに指定された配置場所を変えると、`csrr a0, mhartid`で死ぬことが確認できた。(objdumpで該当命令のアドレスは把握していた)
3. u-bootは`hartid`を`tp`に格納しているので、それを参照することにした。
   1. `hello, world`が表示されないのは、仮想メモリが有効化されていてUARTの物理メモリにアクセスしようとしているところで、実際はただのメモリにアクセスしていたからではないかと仮説を立てて、VMを無効化しようとした。
      1. 状況は改善されなかった。また、VMの無効化ができていたのかもわからなかった。
      2. u-bootのメーリングリストに、「ほとんどの場合仮想メモリは有効化しないか、または、物理メモリと仮想メモリの配置が1:1、すなわち透過性のある設定でしかカーネルに制御は渡さない」と誰かが言っていた。
      3. 僕がu-bootの開発者なら、仮想メモリは有効化してOSに制御は渡したくない。それはOS側で制御したいことのはず。
   2. `hello, world`が表示されないのは、`uartputc_sync()`の中でwhileにトラップされているからなのではないかと仮説を立てて、いったんwhileを外してみた。
      1. `hello, world`と表示された。ただしゴミが大量にプリントされ続けるようになってしまった。
